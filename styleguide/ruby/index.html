<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <meta charset='utf-8' />
    <title>AELOGICA Style Guide</title>
    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css' />
    <link href='http://fonts.googleapis.com/css?family=Anonymous+Pro' rel='stylesheet' type='text/css' />
     <link href='http://corroded.github.com/aelogica-styleguide/stylesheets/screen.css' media='screen' rel='stylesheet' type='text/css'> 
     <link href='http://corroded.github.com/aelogica-styleguide/stylesheets/plugins/snippet.css' media='screen' rel='stylesheet' type='text/css'> 
     <link href='http://corroded.github.com/aelogica-styleguide/stylesheets/print.css' media='screen' rel='stylesheet' type='text/css'> 
    <!--[if IE]>
       <link href='http://corroded.github.com/aelogica-styleguide/stylesheets/ie.css' media='screen' rel='stylesheet' type='text/css'> 
    <![endif]-->
  </head>
  <body>
    <section id='container'>
      <header>
        <div id='logo'>
          <a href='http://aelogica.com'>
            <img alt='creative mobile &amp; web development' src='http://corroded.github.com/aelogica-styleguide/images/cwmd.png ' title='creative mobile &amp; web development' />
          </a>
        </div>
      </header>
      <nav role='navigation'>
        <ul>
          
          
          <li>
            <a class='menu-item' href='http://corroded.github.com/aelogica-styleguide/styleguide/css'>Styling (CSS)</a>
          </li>
          
          
          
          <li>
            <a class='menu-item' href='http://corroded.github.com/aelogica-styleguide/styleguide/html'>Markup (HTML)</a>
          </li>
          
          
          
          <li>
            <a class='menu-item' href='http://corroded.github.com/aelogica-styleguide/styleguide/js'>Behavior (JS)</a>
          </li>
          
          
          
          <li>
            <a class='menu-item current' href='http://corroded.github.com/aelogica-styleguide/styleguide/ruby'>Ruby</a>
          </li>
          
          
        </ul>
      </nav>
      <section id='main-content'>
        <div class='sidebar'>
          <a href='/' title='aelogica'>
            <img alt='aelogica logo' src='http://corroded.github.com/aelogica-styleguide/images/ae.png ' title='aelogica logo' />
          </a>
          
          <section class='table-of-contents'>
            <ul>
              
              <li>
                <a class='chapter' href='#source_code_layout'>Source code layout</a>
              </li>
              
              <li>
                <a class='chapter' href='#syntax'>Syntax</a>
              </li>
              
              <li>
                <a class='chapter' href='#naming'>Naming</a>
              </li>
              
              <li>
                <a class='chapter' href='#comments'>Comments</a>
              </li>
              
              <li>
                <a class='chapter' href='#annotations'>Annotations</a>
              </li>
              
              <li>
                <a class='chapter' href='#classes'>Classes</a>
              </li>
              
              <li>
                <a class='chapter' href='#exceptions'>Exceptions</a>
              </li>
              
              <li>
                <a class='chapter' href='#collections'>Collections</a>
              </li>
              
              <li>
                <a class='chapter' href='#strings'>Strings</a>
              </li>
              
              <li>
                <a class='chapter' href='#regular_expressions'>Regular expressions</a>
              </li>
              
              <li>
                <a class='chapter' href='#percent_literals'>Percent literals</a>
              </li>
              
              <li>
                <a class='chapter' href='#metaprogramming'>Metaprogramming</a>
              </li>
              
              <li>
                <a class='chapter' href='#misc'>Misc</a>
              </li>
              
            </ul>
          </section>
          
        </div>
        <div class='markdown'>
          <h2 id='introduction'>Introduction</h2>

<p>This was taken from <a href='https://github.com/bbatsov/ruby-style-guide/'>bbatsov&#8217;s Ruby Style Guide</a>. We added a couple more examples and fixed some typos, but most of this came from there.</p>

<h2 id='source_code_layout'>Source Code Layout</h2>

<blockquote>
<p>Nearly everybody is convinced that every style but their own is ugly and unreadable. Leave out the &#8220;but their own&#8221; and they&#8217;re probably right&#8230; &#8211; Jerry Coffin (on indentation)</p>
</blockquote>

<ul>
<li>
<p>Use <code>UTF-8</code> as the source file encoding.</p>
</li>

<li>
<p>Use two <strong>spaces</strong> per indentation level.</p>

<pre><code>  # good
  def some_method
    do_something
  end

  # bad - four spaces
  def some_method
      do_something
  end</code></pre>
</li>

<li>
<p>Use Unix-style line endings. (<em>BSD/Solaris/Linux/OSX users are covered by default, Windows users have to be extra careful.)</em> If you&#8217;re using Git you might want to add the following configuration setting to protect your project from Windows line endings creeping in:</p>

<pre><code>  $ git config --global core.autocrlf true</code></pre>
</li>

<li>
<p>Use spaces around operators, after commas, colons and semicolons, around <code>{</code> and before <code>}</code>. Whitespace might be (mostly) irrelevant to the Ruby interpreter, but its proper use is the key to writing easily readable code.</p>

<pre><code>  sum = 1 + 2
  a, b = 1, 2
  1 &gt; 2 ? true : false; puts &#39;Hi&#39;
  [1, 2, 3].each { |e| puts e }</code></pre>

<p>The only exception is when using the exponent operator:</p>

<pre><code>  # bad
  e = M * c ** 2

  # good
  e = M * c**2</code></pre>
</li>

<li>
<p>No spaces after <code>(</code>, <code>[</code> or before <code>]</code>, <code>)</code>.</p>

<pre><code>  some(arg).other
  [1, 2, 3].length</code></pre>
</li>

<li>
<p>Indent <code>when</code> as deep as <code>case</code>. I know that many would disagree with this one, but it&#8217;s the style established in both the &#8220;The Ruby Programming Language&#8221; and &#8220;Programming Ruby&#8221;.</p>

<pre><code>  case
  when song.name == &#39;Misty&#39;
    puts &#39;Not again!&#39;
  when song.duration &gt; 120
    puts &#39;Too long!&#39;
  when Time.now.hour &gt; 21
    puts &quot;It&#39;s too late&quot;
  else
    song.play
  end

  kind = case year
         when 1850..1889 then &#39;Blues&#39;
         when 1890..1909 then &#39;Ragtime&#39;
         when 1910..1929 then &#39;New Orleans Jazz&#39;
         when 1930..1939 then &#39;Swing&#39;
         when 1940..1950 then &#39;Bebop&#39;
         else &#39;Jazz&#39;
         end</code></pre>
</li>

<li>
<p>Use empty lines between <code>def</code>s and to break up a method into logical paragraphs.</p>

<pre><code>  def some_method
    data = initialize(options)

    data.manipulate!

    data.result
  end

  def some_method
    result
  end</code></pre>
</li>

<li>
<p>Align the parameters of a method call if they span over multiple lines.</p>

<pre><code>  # starting point (line is too long)
  def send_mail(source)
    Mailer.deliver(to: &#39;bob@example.com&#39;, from: &#39;us@example.com&#39;, subject: &#39;Important message&#39;, body: source.text)
  end

  # bad (normal indent)
  def send_mail(source)
    Mailer.deliver(
      to: &#39;bob@example.com&#39;,
      from: &#39;us@example.com&#39;,
      subject: &#39;Important message&#39;,
      body: source.text)
  end

  # bad (double indent)
  def send_mail(source)
    Mailer.deliver(
        to: &#39;bob@example.com&#39;,
        from: &#39;us@example.com&#39;,
        subject: &#39;Important message&#39;,
        body: source.text)
  end

  # good
  def send_mail(source)
    Mailer.deliver(to: &#39;bob@example.com&#39;,
                   from: &#39;us@example.com&#39;,
                   subject: &#39;Important message&#39;,
                   body: source.text)
  end</code></pre>
</li>

<li>
<p>Use RDoc and its conventions for API documentation. Don&#8217;t put an empty line between the comment block and the <code>def</code>.</p>
</li>

<li>
<p>Keep lines fewer than 80 characters.</p>
</li>

<li>
<p>Avoid trailing whitespace.</p>
</li>
</ul>

<h2 id='syntax'>Syntax</h2>

<ul>
<li>
<p>Use <code>def</code> with parentheses when there are arguments. Omit the parentheses when the method doesn&#8217;t accept any arguments.</p>

<pre><code>  def some_method
    # body omitted
  end

  def some_method_with_arguments(arg1, arg2)
    # body omitted
  end</code></pre>
</li>

<li>
<p>Never use <code>for</code>, unless you know exactly why. Most of the time iterators should be used instead. <code>for</code> is implemented in terms of <code>each</code> (so you&#8217;re adding a level of indirection), but with a twist - <code>for</code> doesn&#8217;t introduce a new scope (unlike <code>each</code>) and variables defined in its block will be visible outside it.</p>

<pre><code>  arr = [1, 2, 3]

  # bad
  for elem in arr do
    puts elem
  end

  # good
  arr.each { |elem| puts elem }</code></pre>
</li>

<li>
<p>Never use <code>then</code> for multi-line <code>if/unless</code>.</p>

<pre><code>  # bad
  if some_condition then
    # body omitted
  end

  # good
  if some_condition
    # body omitted
  end</code></pre>
</li>

<li>
<p>Favor the ternary operator(<code>?:</code>) over <code>if/then/else/end</code> constructs. It&#8217;s more common and obviously more concise.</p>

<pre><code>  # bad
  result = if some_condition then something else something_else end

  # good
  result = some_condition ? something : something_else</code></pre>
</li>

<li>
<p>Use one expression per branch in a ternary operator. This also means that ternary operators must not be nested. Prefer <code>if/else</code> constructs in these cases.</p>

<pre><code>  # bad
  some_condition ? (nested_condition ? nested_something : nested_something_else) : something_else

  # good
  if some_condition
    nested_condition ? nested_something : nested_something_else
  else
    something_else
  end</code></pre>
</li>

<li>
<p>Never use <code>if x: ...</code> - it is removed in Ruby 1.9. Use the ternary operator instead.</p>

<pre><code>  # bad
  result = if some_condition: something else something_else end

  # good
  result = some_condition ? something : something_else</code></pre>
</li>

<li>
<p>Never use <code>if x; ...</code>. Use the ternary operator instead.</p>
</li>

<li>
<p>Use <code>when x then ...</code> for one-line cases. The alternative syntax <code>when x: ...</code> is removed in Ruby 1.9.</p>
</li>

<li>
<p>Never use <code>when x; ...</code>. See the previous rule.</p>
</li>

<li>
<p>Use <code>&amp;&amp;/||</code> for boolean expressions, <code>and/or</code> for control flow. (Rule of thumb: If you have to use outer parentheses, you are using the wrong operators.)</p>

<pre><code>  # boolean expression
  if some_condition &amp;&amp; some_other_condition
    do_something
  end

  # control flow
  document.saved? or document.save!</code></pre>
</li>

<li>
<p>Avoid multi-line <code>?:</code> (the ternary operator), use <code>if/unless</code> instead.</p>

<pre><code>  # bad
  some_condition ? do_something; and_another_thing : do_something_else

  # good
  if some_condition
    do_something
    and_another_thing
  else
    do_something_else
  end</code></pre>
</li>

<li>
<p>Favor modifier <code>if/unless</code> usage when you have a single-line body. Another good alternative is the usage of control flow <code>and/or</code>.</p>

<pre><code>  # bad
  if some_condition
    do_something
  end

  # good
  do_something if some_condition

  # another good option
  some_condition and do_something</code></pre>
</li>

<li>
<p>Favor <code>unless</code> over <code>if</code> for negative conditions (or control flow <code>or</code>).</p>

<pre><code>  # bad
  do_something if !some_condition

  # good
  do_something unless some_condition

  # another good option
  some_condition or do_something</code></pre>
</li>

<li>
<p>Never use <code>unless</code> with <code>else</code>. Rewrite these with the positive case first.</p>

<pre><code>  # bad
  unless success?
    puts &#39;failure&#39;
  else
    puts &#39;success&#39;
  end

  # good
  if success?
    puts &#39;success&#39;
  else
    puts &#39;failure&#39;
  end</code></pre>
</li>

<li>
<p>Don&#8217;t use parentheses around the condition of an <code>if/unless/while</code>, unless the condition contains an assignment (see &#8220;Using the return value of <code>=</code>&#8221; below).</p>

<pre><code>  # bad
  if (x &gt; 10)
    # body omitted
  end

  # good
  if x &gt; 10
    # body omitted
  end

  # ok
  if (x = self.next_value)
    # body omitted
  end</code></pre>
</li>

<li>
<p>Favor modifier <code>while/until</code> usage when you have a single-line body.</p>

<pre><code>  # bad
  while some_condition
    do_something
  end

  # good
  do_something while some_condition</code></pre>
</li>

<li>
<p>Favor <code>until</code> over <code>while</code> for negative conditions.</p>

<pre><code>  # bad
  do_something while !some_condition

  # good
  do_something until some_condition</code></pre>
</li>

<li>
<p>Omit parentheses around parameters for methods that are part of an internal DSL (e.g. Rake, Rails, RSpec), methods that are with &#8220;keyword&#8221; status in Ruby (e.g. <code>attr_reader</code>, <code>puts</code>) and attribute access methods. Use parentheses around the arguments of all other method invocations.</p>

<pre><code>  class Person
    attr_reader :name, :age

    # omitted
  end

  temperance = Person.new(&#39;Temperance&#39;, 30)
  temperance.name

  puts temperance.age

  x = Math.sin(y)
  array.delete(e)</code></pre>
</li>

<li>
<p>Prefer <code>{...}</code> over <code>do...end</code> for single-line blocks. Avoid using <code>{...}</code> for multi-line blocks (multiline chaining is always ugly). Always use <code>do...end</code> for &#8220;control flow&#8221; and &#8220;method definitions&#8221; (e.g. in Rakefiles and certain DSLs). Avoid <code>do...end</code> when chaining.</p>

<pre><code>  names = [&#39;Bozhidar&#39;, &#39;Steve&#39;, &#39;Sarah&#39;]

  # good
  names.each { |name| puts name }

  # bad
  names.each do |name|
    puts name
  end

  # good
  names.select { |name| name.start_with?(&#39;S&#39;) }.map { |name| name.upcase }

  # bad
  names.select do |name|
    name.start_with?(&#39;S&#39;)
  end.map { |name| name.upcase }</code></pre>

<p>Some will argue that multiline chaining would look OK with the use of , but they should ask themselves - is this code really readable and can&#8217;t the blocks contents be extracted into nifty methods?</p>
</li>

<li>
<p>Avoid <code>return</code> where not required.</p>

<pre><code>  # bad
  def some_method(some_arr)
    return some_arr.size
  end

  # good
  def some_method(some_arr)
    some_arr.size
  end</code></pre>
</li>

<li>
<p>Avoid <code>self</code> where not required.</p>

<pre><code>  # bad
  def ready?
    if self.last_reviewed_at &gt; self.last_updated_at
      self.worker.update(self.content, self.options)
      self.status = :in_progress
    end
    self.status == :verified
  end

  # good
  def ready?
    if last_reviewed_at &gt; last_updated_at
      worker.update(content, options)
      self.status = :in_progress
    end
    status == :verified
  end</code></pre>
</li>

<li>
<p>As a corollary, avoid shadowing methods with local variables unless they are both equivalent</p>

<pre><code>  class Foo
    attr_accessor :options

    # ok
    def initialize(options)
      self.options = options
      # both options and self.options are equivalent here
    end

    # bad
    def do_something(options = {})
      unless options[:when] == :later
        output(self.options[:message])
      end
    end

    # good
    def do_something(params = {})
      unless params[:when] == :later
        output(options[:message])
      end
    end
  end</code></pre>
</li>

<li>
<p>Use spaces around the <code>=</code> operator when assigning default values to method parameters:</p>

<pre><code>  # bad
  def some_method(arg1=:default, arg2=nil, arg3=[])
    # do something...
  end

  # good
  def some_method(arg1 = :default, arg2 = nil, arg3 = [])
    # do something...
  end</code></pre>

<p>While several Ruby books suggest the first style, the second is much more prominent in practice (and arguably a bit more readable).</p>
</li>

<li>
<p>Avoid line continuation (\) where not required. In practice, avoid using line continuations at all.</p>

<pre><code>  # bad
  result = 1 - \
           2

  # good (but still ugly as hell)
  result = 1 \
           - 2</code></pre>
</li>

<li>
<p>Using the return value of <code>=</code> (an assignment) is ok, but surround the assignment with parenthesis.</p>

<pre><code>  # good - shows intended use of assignment
  if (v = array.grep(/foo/)) ...

  # bad
  if v = array.grep(/foo/) ...

  # also good - shows intended use of assignment and has correct precedence.
  if (v = self.next_value) == &#39;hello&#39; ...</code></pre>
</li>

<li>
<p>Use <code>||=</code> freely to initialize variables.</p>

<pre><code>  # set name to Bozhidar, only if it&#39;s nil or false
  name ||= &#39;Bozhidar&#39;</code></pre>
</li>

<li>
<p>Don&#8217;t use <code>||=</code> to initialize boolean variables. (Consider what would happen if the current value happened to be <code>false</code>.)</p>

<pre><code>  # bad - would set enabled to true even if it was false
  enabled ||= true

  # good
  enabled = true if enabled.nil?</code></pre>
</li>

<li>
<p>Avoid using Perl-style special variables (like <code>$0-9</code>, <code>$</code><code>,
etc. ). They are quite cryptic and their use in anything but
one-liner scripts is discouraged.</code></p>
</li>

<li>
<p>Never put a space between a method name and the opening parenthesis.</p>

<pre><code>  # bad
  f (3 + 2) + 1

  # good
  f(3 + 2) + 1</code></pre>
</li>

<li>
<p>If the first argument to a method begins with an open parenthesis, always use parentheses in the method invocation. For example, write <code>f((3 + 2) + 1)</code>.</p>
</li>

<li>
<p>Always run the Ruby interpreter with the <code>-w</code> option so it will warn you if you forget either of the rules above!</p>
</li>

<li>
<p>When the keys of your hash are symbols use the Ruby 1.9 hash literal syntax.</p>

<pre><code>  # bad
  hash = { :one =&gt; 1, :two =&gt; 2 }

  # good
  hash = { one: 1, two: 2 }</code></pre>
</li>

<li>
<p>Use the new lambda literal syntax.</p>

<pre><code>  # bad
  lambda = lambda { |a, b| a + b }
  lambda.call(1, 2)

  # good
  lambda = -&gt;(a, b) { a + b }
  lambda.(1, 2)</code></pre>
</li>

<li>
<p>Use <code>_</code> for unused block parameters.</p>

<pre><code>  # bad
  result = hash.map { |k, v| v + 1 }

  # good
  result = hash.map { |_, v| v + 1 }</code></pre>
</li>
</ul>

<h2 id='naming'>Naming</h2>

<blockquote>
<p>The only real difficulties in programming are cache invalidation and naming things. &#8211; Phil Karlton</p>
</blockquote>

<ul>
<li>
<p>Use <code>snake_case</code> for methods and variables.</p>
</li>

<li>
<p>Use <code>CamelCase</code> for classes and modules. (Keep acronyms like HTTP, RFC, XML uppercase.)</p>
</li>

<li>
<p>Use <code>SCREAMING_SNAKE_CASE</code> for other constants.</p>
</li>

<li>
<p>The names of predicate methods (methods that return a boolean value) should end in a question mark. (i.e. <code>Array#empty?</code>).</p>
</li>

<li>
<p>The names of potentially &#8220;dangerous&#8221; methods (i.e. methods that modify <code>self</code> or the arguments, <code>exit!</code> (doesn&#8217;t run the finalizers like <code>exit</code> does), etc.) should end with an exclamation mark if there exists a safe version of that <em>dangerous</em> method.</p>

<pre><code>  # bad - there is not matching &#39;safe&#39; method
  class Person
    def update!
    end
  end

  # good
  class Person
    def update
    end
  end

  # good
  class Person
    def update!
    end

    def update
    end
  end</code></pre>
</li>

<li>
<p>Define the non-bang (safe) method in terms of the bang (dangerous) one if possible.</p>

<pre><code>  class Array
    def flatten_once!
      res = []

      each do |e|
        [*e].each { |f| res &lt;&lt; f }
      end

      replace(res)
    end

    def flatten_once
      dup.flatten_once!
    end
  end</code></pre>
</li>

<li>
<p>When using <code>reduce</code> with short blocks, name the arguments <code>|a, e|</code> (accumulator, element).</p>

<pre><code>  # bad
  longest = %w{ cat sheep bear }.reduce do |m,w|
   m.length &gt; w.length ? m : w
  end

  # good
  longest = %w{ cat sheep bear }.reduce do |memo,word|
    memo.length &gt; word.length ? memo : word
  end</code></pre>
</li>

<li>
<p>When defining binary operators, name the argument <code>other</code>.</p>

<pre><code>  def +(other)
    # body omitted
  end</code></pre>
</li>

<li>
<p>Prefer <code>map</code> over <code>collect</code>, <code>find</code> over <code>detect</code>, <code>select</code> over <code>find_all</code>, <code>reduce</code> over <code>inject</code> and <code>size</code> over <code>length</code>. This is not a hard requirement; if the use of the alias enhances readability, it&#8217;s ok to use it. The rhyming methods are inherited from Smalltalk and are not common in other programming languages. The reason the use of <code>select</code> is encouraged over <code>find_all</code> is that it goes together nicely with <code>reject</code> and its name is pretty self-explanatory.</p>
</li>
</ul>

<h2 id='comments'>Comments</h2>

<blockquote>
<p>Good code is its own best documentation. As you&#8217;re about to add a comment, ask yourself, &#8220;How can I improve the code so that this comment isn&#8217;t needed?&#8221; Improve the code and then document it to make it even clearer. &#8211; Steve McConnell</p>
</blockquote>

<ul>
<li>
<p>Write self-documenting code and ignore the rest of this section. Seriously!</p>
</li>

<li>
<p>Comments longer than a word are capitalized and use punctuation. Use <a href='http://en.wikipedia.org/wiki/Sentence_spacing'>one space</a> after periods.</p>
</li>

<li>
<p>Avoid superfluous comments.</p>

<pre><code>  # bad
  counter += 1 # increments counter by one</code></pre>
</li>

<li>
<p>Keep existing comments up-to-date. An outdated comment is worse than no comment at all.</p>
</li>
</ul>

<blockquote>
<p>Good code is like a good joke - it needs no explanation. &#8211; Russ Olsen</p>
</blockquote>

<ul>
<li>Avoid writing comments to explain bad code. Refactor the code to make it self-explanatory. (Do or do not - there is no try. &#8211;Yoda)</li>
</ul>

<h2 id='annotations'>Annotations</h2>

<ul>
<li>
<p>Annotations should usually be written on the line immediately above the relevant code.</p>
</li>

<li>
<p>The annotation keyword is followed by a colon and a space, then a note describing the problem.</p>
</li>

<li>
<p>If multiple lines are required to describe the problem, subsequent lines should be indented two spaces after the <code>#</code>.</p>

<pre><code>  def bar
    # FIXME: This has crashed occasionally since v3.2.1. It may
    #   be related to the BarBazUtil upgrade.
    baz(:quux)
  end</code></pre>
</li>

<li>
<p>In cases where the problem is so obvious that any documentation would be redundant, annotations may be left at the end of the offending line with no note. This usage should be the exception and not the rule.</p>

<pre><code>  def bar
    sleep 100 # OPTIMIZE
  end</code></pre>
</li>

<li>
<p>Use <code>TODO</code> to note missing features or functionality that should be added at a later date.</p>
</li>

<li>
<p>Use <code>FIXME</code> to note broken code that needs to be fixed.</p>
</li>

<li>
<p>Use <code>OPTIMIZE</code> to note slow or inefficient code that may cause performance problems.</p>
</li>

<li>
<p>Use <code>HACK</code> to note code smells where questionable coding practices were used and should be refactored away.</p>
</li>

<li>
<p>Use <code>REVIEW</code> to note anything that should be looked at to confirm it is working as intended. For example: <code>REVIEW: Are we sure this is how the
client does X currently?</code></p>
</li>

<li>
<p>Use other custom annotation keywords if it feels appropriate, but be sure to document them in your project&#8217;s <code>README</code> or similar.</p>
</li>
</ul>

<h2 id='classes'>Classes</h2>

<ul>
<li>
<p>When designing class hierarchies make sure that they conform to the <a href='http://en.wikipedia.org/wiki/Liskov_substitution_principle'>Liskov Substitution Principle</a>.</p>
</li>

<li>
<p>Try to make your classes as <a href='http://en.wikipedia.org/wiki/SOLID_(object-oriented_design\)'>SOLID</a> as possible.</p>
</li>

<li>
<p>Always supply a proper <code>to_s</code> method for classes that represent domain objects.</p>

<pre><code>  class Person
    attr_reader :first_name, :last_name

    def initialize(first_name, last_name)
      @first_name = first_name
      @last_name = last_name
    end

    def to_s
      &quot;#@first_name #@last_name&quot;
    end
  end</code></pre>
</li>

<li>
<p>Use the <code>attr</code> family of functions to define trivial accessors or mutators.</p>

<pre><code>  # bad
  class Person
    def initialize(first_name, last_name)
      @first_name = first_name
      @last_name = last_name
    end

    def first_name
      @first_name
    end

    def last_name
      @last_name
    end
  end

  # good
  class Person
    attr_reader :first_name, :last_name

    def initialize(first_name, last_name)
      @first_name = first_name
      @last_name = last_name
    end
  end</code></pre>
</li>

<li>
<p>Consider using <code>Struct.new</code>, which defines the trivial accessors, constructor and comparison operators for you.</p>

<pre><code>  # good
  class Person
    attr_reader :first_name, :last_name

    def initialize(first_name, last_name)
      @first_name = first_name
      @last_name = last_name
    end
  end

  # better
  class Person &lt; Struct.new(:first_name, :last_name)
  end
  `</code></pre>
</li>

<li>
<p>Consider adding factory methods to provide additional sensible ways to create instances of a particular class.</p>

<pre><code>  class Person
    def self.create(options_hash)
      # body omitted
    end
  end</code></pre>
</li>

<li>
<p>Prefer <a href='http://en.wikipedia.org/wiki/Duck_typing'>duck-typing</a> over inheritance.</p>

<pre><code>  # bad
  class Animal
    # abstract method
    def speak
    end
  end

  # extend superclass
  class Duck &lt; Animal
    def speak
      puts &#39;Quack! Quack&#39;
    end
  end

  # extend superclass
  class Dog &lt; Animal
    def speak
      puts &#39;Bau! Bau!&#39;
    end
  end

  # good
  class Duck
    def speak
      puts &#39;Quack! Quack&#39;
    end
  end

  class Dog
    def speak
      puts &#39;Bau! Bau!&#39;
    end
  end</code></pre>
</li>

<li>
<p>Avoid the usage of class (<code>@@</code>) variables due to their &#8220;nasty&#8221; behavior in inheritance.</p>

<pre><code>  class Parent
    @@class_var = &#39;parent&#39;

    def self.print_class_var
      puts @@class_var
    end
  end

  class Child &lt; Parent
    @@class_var = &#39;child&#39;
  end

  Parent.print_class_var # =&gt; will print &quot;child&quot;</code></pre>

<p>As you can see all the classes in a class hierarchy actually share one class variable. Class instance variables should usually be preferred over class variables.</p>
</li>

<li>
<p>Assign proper visibility levels to methods (<code>private</code>, <code>protected</code>) in accordance with their intended usage. Don&#8217;t go off leaving everything <code>public</code> (which is the default). After all we&#8217;re coding in <em>Ruby</em> now, not in <em>Python</em>.</p>
</li>

<li>
<p>Indent the <code>public</code>, <code>protected</code>, and <code>private</code> methods as much the method definitions they apply to. Leave one blank line above them.</p>

<pre><code>  class SomeClass
    def public_method
      # ...
    end

    private
    def private_method
      # ...
    end
  end</code></pre>
</li>

<li>
<p>Use <code>def self.method</code> to define singleton methods. This makes the methods more resistant to refactoring changes.</p>

<pre><code>  class TestClass
    # bad
    def TestClass.some_method
      # body omitted
    end

    # good
    def self.some_other_method
      # body omitted
    end

    # Also possible and convenient when you
    # have to define many singleton methods.
    class &lt;&lt; self
      def first_method
        # body omitted
      end

      def second_method_etc
        # body omitted
      end
    end
  end</code></pre>
</li>
</ul>

<h2 id='exceptions'>Exceptions</h2>

<ul>
<li>
<p>Signal exceptions using the <code>fail</code> keyword. Use <code>raise</code> only when catching an exception and re-raising it (because here you&#8217;re not failing, but explicitly and purposefully raising an exception).</p>

<pre><code>  begin
    fail &#39;Oops&#39;;
  rescue =&gt; error
    raise if error.message != &#39;Oops&#39;
  end</code></pre>
</li>

<li>
<p>Never return from an <code>ensure</code> block. If you explicitly return from a method inside an <code>ensure</code> block, the return will take precedence over any exception being raised, and the method will return as if no exception had been raised at all. In effect, the exception will be silently thrown away.</p>

<pre><code>  def foo
    begin
      fail
    ensure
      return &#39;very bad idea&#39;
    end
  end</code></pre>
</li>

<li>
<p>Use <em>implicit begin blocks</em> when possible.</p>

<pre><code>  # bad
  def foo
    begin
      # main logic goes here
    rescue
      # failure handling goes here
    end
  end

  # good
  def foo
    # main logic goes here
  rescue
    # failure handling goes here
  end</code></pre>
</li>

<li>
<p>Mitigate the proliferation of <code>begin</code> blocks via the use of <em>contingency methods</em> (a term coined by Avdi Grimm).</p>

<pre><code>  # bad
  begin
    something_that_might_fail
  rescue IOError
    # handle IOError
  end

  begin
    something_else_that_might_fail
  rescue IOError
    # handle IOError
  end

  # good
  def with_io_error_handling
     yield
  rescue
    # handle IOError
  end

  with_io_error_handling { something_that_might_fail }

  with_io_error_handling { something_else_that_might_fail }</code></pre>
</li>

<li>
<p>Don&#8217;t suppress exceptions.</p>

<pre><code>  # bad
  begin
    # an exception occurs here
  rescue SomeError
    # the rescue clause does absolutely nothing
  end

  # bad
  do_something rescue nil</code></pre>
</li>

<li>
<p>Don&#8217;t use exceptions for flow of control.</p>

<pre><code>  # bad
  begin
    n / d
  rescue ZeroDivisionError
    puts &#39;Cannot divide by 0!&#39;
  end

  # good
  if d.zero?
    puts &#39;Cannot divide by 0!&#39;
  else
    n / d
  end</code></pre>
</li>

<li>
<p>Avoid rescuing the <code>Exception</code> class. This will trap signals and calls to <code>exit</code>, requiring you to <code>kill -9</code> the process.</p>

<pre><code>  # bad
  begin
    # calls to exit and kill signals will be caught (except kill -9)
    exit
  rescue Exception
    puts &quot;you didn&#39;t really want to exit, right?&quot;
    # exception handling
  end

  # good
  begin
    # a blind rescue rescues from StandardError, not Exception as many
    # programmers assume.
  rescue =&gt; e
    # exception handling
  end

  # also good
  begin
    # an exception occurs here

  rescue StandardError =&gt; e
    # exception handling
  end</code></pre>
</li>

<li>
<p>Put more specific exceptions higher up the rescue chain, otherwise they&#8217;ll never be rescued from.</p>

<pre><code>  # bad
  begin
    # some code
  rescue Exception =&gt; e
    # some handling
  rescue StandardError =&gt; e
    # some handling
  end

  # good
  begin
    # some code
  rescue StandardError =&gt; e
    # some handling
  rescue Exception =&gt; e
    # some handling
  end</code></pre>
</li>

<li>
<p>Release external resources obtained by your program in an ensure block.</p>

<pre><code>  f = File.open(&#39;testfile&#39;)
  begin
    # .. process
  rescue
    # .. handle error
  ensure
    f.close unless f.nil?
  end</code></pre>
</li>

<li>
<p>Favor the use of exceptions for the standard library over introducing new exception classes.</p>
</li>
</ul>

<h2 id='collections'>Collections</h2>

<ul>
<li>
<p>Prefer literal array and hash creation notation (unless you need to pass parameters to their constructors, that is).</p>

<pre><code>  # bad
  arr = Array.new
  hash = Hash.new

  # good
  arr = []
  hash = {}</code></pre>
</li>

<li>
<p>Prefer <code>%w</code> to the literal array syntax when you need an array of strings.</p>

<pre><code>  # bad
  STATES = [&#39;draft&#39;, &#39;open&#39;, &#39;closed&#39;]

  # good
  STATES = %w(draft open closed)</code></pre>
</li>

<li>
<p>Avoid the creation of huge gaps in arrays.</p>

<pre><code>  arr = []
  arr[100] = 1 # now you have an array with lots of nils</code></pre>
</li>

<li>
<p>Use <code>Set</code> instead of <code>Array</code> when dealing with unique elements. <code>Set</code> implements a collection of unordered values with no duplicates. This is a hybrid of <code>Array</code>&#8217;s intuitive inter-operation facilities and <code>Hash</code>&#8217;s fast lookup.</p>

<pre><code>  # bad
  def add_if_unique(array, element)
    array &lt;&lt; element
    array.uniq
  end

  # good
  require &#39;set&#39;

  a = [1,2,3].to_set
  a &lt;&lt; 3
  a.to_a

  puts a
  # [1,2,3]</code></pre>
</li>

<li>
<p>Use symbols instead of strings as hash keys.</p>

<pre><code>  # bad
  hash = { &#39;one&#39; =&gt; 1, &#39;two&#39; =&gt; 2, &#39;three&#39; =&gt; 3 }

  # good
  hash = { one: 1, two: 2, three: 3 }</code></pre>
</li>

<li>
<p>Avoid the use of mutable object as hash keys.</p>
</li>

<li>
<p>Use the new 1.9 literal hash syntax in preference to the hashrocket syntax.</p>

<pre><code>  # bad
  hash = { :one =&gt; 1, :two =&gt; 2, :three =&gt; 3 }

  # good
  hash = { one: 1, two: 2, three: 3 }</code></pre>
</li>

<li>
<p>Rely on the fact that hashes in 1.9 are ordered.</p>
</li>

<li>
<p>Never modify a collection while traversing it.</p>
</li>
</ul>

<h2 id='strings'>Strings</h2>

<ul>
<li>
<p>Prefer string interpolation instead of string concatenation:</p>

<pre><code>  # bad
  email_with_name = user.name + &#39; &lt;&#39; + user.email + &#39;&gt;&#39;

  # good
  email_with_name = &quot;#{user.name} &lt;#{user.email}&gt;&quot;</code></pre>
</li>

<li>
<p>Consider padding string interpolation code with space. It more clearly sets the code apart from the string.</p>

<pre><code>  &quot;#{ user.last_name }, #{ user.first_name }&quot;</code></pre>
</li>

<li>
<p>Prefer single-quoted strings when you don&#8217;t need string interpolation or special symbols such as <code>\t</code>, <code>\n</code>, <code>&#39;</code>, etc.</p>

<pre><code>  # bad
  name = &quot;Bozhidar&quot;

  # good
  name = &#39;Bozhidar&#39;</code></pre>
</li>

<li>
<p>Don&#8217;t use <code>{}</code> around instance variables being interpolated into a string.</p>

<pre><code>  class Person
    attr_reader :first_name, :last_name

    def initialize(first_name, last_name)
      @first_name = first_name
      @last_name = last_name
    end

    # bad
    def to_s
      &quot;#{@first_name} #{@last_name}&quot;
    end

    # good
    def to_s
      &quot;#@first_name #@last_name&quot;
    end
  end</code></pre>
</li>

<li>
<p>Avoid using <code>String#+</code> when you need to construct large data chunks. Instead, use <code>String#&lt;&lt;</code>. Concatenation mutates the string instance in-place and is always faster than <code>String#+</code>, which creates a bunch of new string objects.</p>

<pre><code>  # good and also fast
  html = &#39;&#39;
  html &lt;&lt; &#39;&lt;h1&gt;Page title&lt;/h1&gt;&#39;

  paragraphs.each do |paragraph|
    html &lt;&lt; &quot;&lt;p&gt;#{paragraph}&lt;/p&gt;&quot;
  end</code></pre>
</li>
</ul>

<h2 id='regular_expressions'>Regular Expressions</h2>

<ul>
<li>
<p>Don&#8217;t use regular expressions if you just need plain text search in string: <code>string[&#39;text&#39;]</code></p>
</li>

<li>
<p>For simple constructions you can use regexp directly through string index.</p>

<pre><code>  match = string[/regexp/]             # get content of matched regexp
  first_group = string[/text(grp)/, 1] # get content of captured group
  string[/text (grp)/, 1] = &#39;replace&#39;  # string =&gt; &#39;text replace&#39;</code></pre>
</li>

<li>
<p>Use non capturing groups when you don&#8217;t use captured result of parenthesis.</p>

<pre><code>  /(first|second)/   # bad
  /(?:first|second)/ # good</code></pre>
</li>

<li>
<p>Avoid using $1-9 as it can be hard to track what they contain. Named groups can be used instead.</p>

<pre><code>  # bad
  /(regexp)/ =~ string
  ...
  process $1

  # good
  /(?&lt;meaningful_var&gt;regexp)/ =~ string
  ...
  process meaningful_var</code></pre>
</li>

<li>
<p>Character classes have only few special characters you should care about: <code>^</code>, <code>-</code>, <code>\</code>, <code>]</code>, so don&#8217;t escape <code>.</code> or brackets in <code>[]</code>.</p>
</li>

<li>
<p>Be careful with <code>^</code> and <code>$</code> as they match start/end of line, not string endings. If you want to match the whole string use: <code>\A</code> and <code>\z</code> (not to be confused with <code>\Z</code> which is the equivalent of <code>/\n?\z/</code>).</p>

<pre><code>  string = &quot;some injection\nusername&quot;
  string[/^username$/]   # matches
  string[/\Ausername\z/] # don&#39;t match</code></pre>
</li>

<li>
<p>Use <code>x</code> modifier for complex regexps. This makes them more readable and you can add some useful comments. Just be careful as spaces are ignored.</p>

<pre><code>  regexp = %r{
    start         # some text
    \s            # white space char
    (group)       # first group
    (?:alt1|alt2) # some alternation
    end
  }x</code></pre>
</li>

<li>
<p>For complex replacements <code>sub</code>/<code>gsub</code> can be used with block or hash.</p>
</li>
</ul>

<h2 id='percent_literals'>Percent Literals</h2>

<ul>
<li>
<p>Use <code>%w</code> freely.</p>

<pre><code>  STATES = %w(draft open closed)</code></pre>
</li>

<li>
<p>Use <code>%()</code> for single-line strings which require both interpolation and embedded double-quotes. For multi-line strings, prefer heredocs.</p>

<pre><code>  # bad (no interpolation needed)
  %(&lt;div class=&quot;text&quot;&gt;Some text&lt;/div&gt;)

  # should be
  &#39;&lt;div class=&quot;text&quot;&gt;Some text&lt;/div&gt;&#39;

  # bad (no double-quotes)
  %(This is #{quality} style)

  # should be
  &quot;This is #{quality} style&quot;

  # bad (multiple lines)
  %(&lt;div&gt;\n&lt;span class=&quot;big&quot;&gt;#{exclamation}&lt;/span&gt;\n&lt;/div&gt;)

  # should be a heredoc.

  # good (requires interpolation, has quotes, single line)
  %(&lt;tr&gt;&lt;td class=&quot;name&quot;&gt;#{name}&lt;/td&gt;)</code></pre>
</li>

<li>
<p>Use <code>%r</code> only for regular expressions matching <em>more than</em> one &#8217;/&#8217; character.</p>

<pre><code>  # bad
  %r(\s+)

  # still bad
  %r(^/(.*)$)
  # should be /^\/(.*)$/

  # good
  %r(^/blog/2011/(.*)$)</code></pre>
</li>

<li>
<p>Avoid <code>%q</code>, <code>%Q</code>, <code>%x</code>, <code>%s</code>, and <code>%W</code>.</p>
</li>

<li>
<p>Prefer <code>()</code> as delimiters for all <code>%</code> literals.</p>
</li>
</ul>

<h2 id='metaprogramming'>Metaprogramming</h2>

<ul>
<li>
<p>Do not mess around in core classes when writing libraries. (Do not monkey patch them.)</p>
</li>

<li>
<p>The block form of <code>class_eval</code> is preferable to the string-interpolated form. - when you use the string-interpolated form, always supply <code>__FILE__</code> and <code>__LINE__</code>, so that your backtraces make sense:</p>

<p>ruby class_eval &#8216;def use_relative_model_naming?; true; end&#8217;, <strong>FILE</strong>, <strong>LINE</strong></p>

<ul>
<li><code>define_method</code> is preferable to <code>class_eval{ def ... }</code></li>
</ul>
</li>

<li>
<p>When using <code>class_eval</code> (or other <code>eval</code>) with string interpolation, add a comment block showing its appearance if interpolated (a practice I learned from the rails code):</p>

<p>ruby # from activesupport/lib/active_support/core_ext/string/output_safety.rb UNSAFE_STRING_METHODS.each do |unsafe_method| if &#8216;String&#8217;.respond_to?(unsafe_method) class_eval &#171;-EOT, <strong>FILE</strong>, <strong>LINE</strong> + 1 def #{unsafe_method}(<em>args, &amp;block) # def capitalize(</em>args, &amp;block) to_str.#{unsafe_method}(<em>args, &amp;block) # to_str.capitalize(</em>args, &amp;block) end # end</p>

<pre><code>    def #{unsafe_method}!(*args)              # def capitalize!(*args)
      @dirty = true                           #   @dirty = true
      super                                   #   super
    end                                       # end
  EOT
end</code></pre>

<p>end</p>
</li>

<li>
<p>avoid using <code>method_missing</code> for metaprogramming. Backtraces become messy; the behavior is not listed in <code>#methods</code>; misspelled method calls might silently work (<code>nukes.launch_state = false</code>). Consider using delegation, proxy, or <code>define_method</code> instead. If you must, use <code>method_missing</code>,</p>

<ul>
<li>
<p>be sure to <a href='http://blog.marc-andre.ca/2010/11/methodmissing-politely.html'>also define <code>respond_to_missing?</code></a></p>
</li>

<li>
<p>only catch methods with a well-defined prefix, such as <code>find_by_*</code> &#8211; make your code as assertive as possible.</p>
</li>

<li>
<p>call <code>super</code> at the end of your statement</p>
</li>

<li>
<p>delegate to assertive, non-magical methods:</p>

<pre><code># bad
def method_missing?(meth, *args, &amp;block)
  if /^find_by_(?&lt;prop&gt;.*)/ =~ meth
    # ... lots of code to do a find_by
  else
    super
  end
end

# good
def method_missing?(meth, *args, &amp;block)
  if /^find_by_(?&lt;prop&gt;.*)/ =~ meth
    find_by(prop, *args, &amp;block)
  else
    super
  end
end

# best of all, though, would be to define_method as each findable attribute is declared</code></pre>
</li>
</ul>
</li>
</ul>

<h2 id='misc'>Misc</h2>

<ul>
<li>
<p>Write <code>ruby -w</code> safe code.</p>
</li>

<li>
<p>Avoid hashes as optional parameters. Does the method do too much?</p>
</li>

<li>
<p>Avoid methods longer than 10 LOC (lines of code). Ideally, most methods will be shorter than 5 LOC. Empty lines do not contribute to the relevant LOC.</p>
</li>

<li>
<p>Avoid parameter lists longer than three or four parameters.</p>
</li>

<li>
<p>If you really have to, add &#8220;global&#8221; methods to Kernel and make them private.</p>
</li>

<li>
<p>Use class instance variables instead of global variables.</p>

<pre><code>  #bad
  $foo_bar = 1

  #good
  class Foo
    class &lt;&lt; self
      attr_accessor :bar
    end
  end

  Foo.bar = 1</code></pre>
</li>

<li>
<p>Avoid <code>alias</code> when <code>alias_method</code> will do.</p>
</li>

<li>
<p>Use <code>OptionParser</code> for parsing complex command line options and <code>ruby -s</code> for trivial command line options.</p>
</li>

<li>
<p>Code in a functional way, avoiding mutation when that makes sense.</p>
</li>

<li>
<p>Avoid needless metaprogramming.</p>
</li>

<li>
<p>Do not mutate arguments unless that is the purpose of the method.</p>
</li>

<li>
<p>Avoid more than three levels of block nesting.</p>
</li>

<li>
<p>Be consistent. In an ideal world, be consistent with these guidelines.</p>
</li>

<li>
<p>Use common sense.</p>
</li>
</ul>

<h1 id='contributing'>Contributing</h1>

<p>Nothing written in this guide is set in stone. It&#8217;s my desire to work together with everyone interested in Ruby coding style, so that we could ultimately create a resource that will be beneficial to the entire Ruby community.</p>

<p>Feel free to open tickets or send pull requests with improvements. Thanks in advance for your help!</p>

<h1 id='spread_the_word'>Spread the Word</h1>

<p>A community-driven style guide is of little use to a community that doesn&#8217;t know about its existence. Tweet about the guide, share it with your friends and colleagues. Every comment, suggestion or opinion we get makes the guide just a little bit better. And we want to have the best possible guide, don&#8217;t we?</p>
        </div>
      </section>
      <footer>
        <p>
          Hosted on Github Pages
        </p>
      </footer>
    </section>
     <script src='http://corroded.github.com/aelogica-styleguide/javascripts/jquery-1.7.2.min.js' type='text/javascript'></script> 
     <script src='http://corroded.github.com/aelogica-styleguide/javascripts/jquery.snippet.min.js' type='text/javascript'></script> 
     <script src='http://corroded.github.com/aelogica-styleguide/javascripts/main.js' type='text/javascript'></script> 
  </body>
</html>
